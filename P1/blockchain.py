"""
Explanation:

Blockchain is represented using a linked list here. Adding a new block calculates
the hash using block's data and hash of previous block.

Complexity:

Adding blocks to blockchain is constant time operation = O(1)
"""

import hashlib
from datetime import datetime


class Block:
    def __init__(self, timestamp, data, previous_hash):
        self.timestamp = timestamp
        self.data = data
        self.previous_hash = previous_hash
        self.hash = self.calc_hash()
        self.next = None

    def calc_hash(self):
        sha = hashlib.sha256()
        hash_str = f'{self.__str__()}'.encode('utf-8')
        sha.update(hash_str)
        return sha.hexdigest()

    def __str__(self):
        return f'{self.timestamp} {self.data} {self.previous_hash}'


class BlockChain:
    def __init__(self):
        self.head = None
        self.tail = self.head

    def add(self, data):
        prev_hash = self.tail.hash if self.tail else None
        new_block = Block(datetime.utcnow().strftime('%H:%M %m-%d-%Y'), data, prev_hash)

        if self.tail is None:
            self.head = new_block
            self.tail = new_block
        else:
            self.tail.next = new_block
            self.tail = new_block

    def __iter__(self):
        head = self.head
        while head:
            yield head
            head = head.next


if __name__ == "__main__":

    def test_case1():
        block_chain = BlockChain()

        block_chain.add('Genesis Block!')
        block_chain.add('Block1')
        block_chain.add('Block2')

        # each block has hash of its previous
        # block in previous_hash
        previous = None
        for block in block_chain:
            if previous is not None:
                assert block.previous_hash == previous.hash

            previous = block

    def test_case2():
        block_chain = BlockChain()

        block_chain.add('Genesis Block!')
        block_chain.add('Block1')

        # a tampered block's hash will not match with
        # hash generated by using previous block's hash
        tempered_block = block_chain.tail
        tempered_block.data = 'Tempered Data!!'
        tempered_block.previous_hash = 'fake_hash'
        tempered_block.hash = tempered_block.calc_hash()

        previous_block = block_chain.head
        sha = hashlib.sha256()
        hash_str = f'{tempered_block.timestamp} {tempered_block.data} {previous_block.hash}'.encode('utf-8')
        sha.update(hash_str)

        assert sha.hexdigest() != tempered_block.hash


    for i, test in enumerate([test_case1, test_case2,]):
        try:
            test()
            print(f'Test {i+1}: Passed')
        except AssertionError:
            print(f'Test {i+1}: Failed')
