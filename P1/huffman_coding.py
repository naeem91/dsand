"""
Explanation:

Huffman encoding is done in following steps:

1. First a tree is generated by creating nodes representing character and its frequency of occurrence. Nodes are
kept in a list. Frequencies are put into a min heap, and two are popped out at a time to generate
a parent node until the whole queue is used.

2. The generated tree is traversed in DFS manner and all left nodes of parent are assigned 0 weight and all
right nodes of parent are assigned 1 weight at each level.

3. The binary values assigned to nodes are used to create a encoding map of characters.

4. Characters in the data are replaced with their binary values

Complexity:


Time:
each character in data is visited to find out frequency = O(n)
min heap push and pop =  O(k) where k = unique character count
assign values to nodes = O(k)
encoding each character = O(n)

In worst case huffman encoding = O(n)
on average = O(k) where k = unique character count

huffman decoding = O(n)

"""

import sys
import heapq
from collections import defaultdict


class Node:
    def __init__(self, frequency):
        self.frequency = frequency
        self.character = None
        self.value = None
        self.left = None
        self.right = None

    def has_left_child(self):
        return self.left is not None

    def has_right_child(self):
        return self.right is not None

    def get_left_child(self):
        return self.left

    def get_right_child(self):
        return self.right

    def __repr__(self):
        return f'{self.character}({self.frequency})'


def _assign_values(root):
    """
    Traverse the tree and assign binary values to nodes
    """
    if not any([root.has_left_child(), root.has_right_child()]):
        return root

    left_nodes = []
    right_nodes = []

    if root.has_left_child():
        l_n = _assign_values(root.get_left_child())
        if type(l_n) == list:
            for n in l_n:
                n.value = f'0{n.value}'

            left_nodes = l_n
        else:
            left_nodes.append(l_n)

    if root.has_right_child():
        r_n = _assign_values(root.get_right_child())
        if type(r_n) == list:
            for n in r_n:
                n.value = f'1{n.value}'

            right_nodes = r_n
        else:
            right_nodes.append(r_n)

    return [*left_nodes, *right_nodes]


def _generate_huffman_tree(data):
    # find out frequency
    frequency_map = defaultdict(int)
    for ch in data:
        frequency_map[ch] += 1

    # create nodes and place in a map
    nodes_map = defaultdict(list)
    for ch, f in frequency_map.items():
        node = Node(frequency=f)
        node.character = ch

        nodes_map[f].append(node)

    queue = list(frequency_map.values())
    heapq.heapify(queue)

    while len(queue) > 1:
        smallest1 = heapq.heappop(queue)
        smallest2 = heapq.heappop(queue)

        right = nodes_map[smallest1].pop()
        left = nodes_map[smallest2].pop()

        if left.frequency > right.frequency:
            right, left = left, right

        left.value = '0'
        right.value = '1'

        parent = Node(frequency=left.frequency + right.frequency)
        parent.left = left
        parent.right = right

        nodes_map[parent.frequency].append(parent)

        heapq.heappush(queue, parent.frequency)

    last = heapq.heappop(queue)
    root = nodes_map[last].pop()

    return root


def huffman_encoding(data):
    if not data:
        raise ValueError('Nothing to encode!')

    root = _generate_huffman_tree(data)
    weighted_nodes = _assign_values(root)

    if type(weighted_nodes) == list:
        encoding_map = {node.character:node.value for node in weighted_nodes}
    else:
        encoding_map = {weighted_nodes.character: '1'}

    encoded_data = ''

    for ch in data:
        encoded_data += encoding_map[ch]

    return encoded_data, root


def huffman_decoding(data, root):
    decoded_string = ''
    head = root

    for char in data:
        if not any([head.has_left_child(), head.has_right_child()]):
            decoded_string += head.character

            if head == root:
                # one node tree
                continue
            else:
                # reset to root
                head = root

        if char == '0':
            head = head.get_left_child()

        if char == '1':
            head = head.get_right_child()

    if head != root:
        decoded_string += head.character

    return decoded_string



if __name__ == "__main__":
    def test_case1():
        sentence = "The bird is the word"
        encoded_data, tree = huffman_encoding(sentence)

        decoded_data = huffman_decoding(encoded_data, tree)

        assert decoded_data == sentence
        assert sys.getsizeof(int(encoded_data, base=2)) < sys.getsizeof(sentence)

    def test_case2():
        sentence = 'A'
        encoded_data, tree = huffman_encoding(sentence)

        decoded_data = huffman_decoding(encoded_data, tree)

        assert decoded_data == sentence
        assert sys.getsizeof(int(encoded_data, base=2)) < sys.getsizeof(sentence)

    def test_case3():
        sentence = 'AAAAAAABBBCCCCCCCDDEEEEEE'
        encoded_data, tree = huffman_encoding(sentence)

        decoded_data = huffman_decoding(encoded_data, tree)

        assert decoded_data == sentence
        assert sys.getsizeof(int(encoded_data, base=2)) < sys.getsizeof(sentence)

    for i, test in enumerate([test_case1, test_case2, test_case3]):
        try:
            test()
            print(f'Test {i+1}: Passed')
        except AssertionError:
            print(f'Test {i+1}: Failed')
