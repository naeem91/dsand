---------------------
Problem 1: LRU Cache
---------------------

LRUCache uses a dict to store key and values, because dict has constant time get and set.

A queue is used to handle eviction of the least recently used keys. Whenever a key is set or get, it is pushed to the
very last of the queue, that makes the least recently keys move to the first spots and get evicted when capacity
is reached.

All operations are constant time:

Dict set, get and delete = O(1)
Stack push and pop = O(1)

Space complexity is O(k) where k is capacity of cache

-------------------------
Problem 2: File Recursion
-------------------------

The search goes by DFS, all the files with suffix are added into a list.

Complexity:

Time:
visiting paths = O(n)
checking if a file path ends with suffix = O(1)

overall it is proportional to no. of paths = O(n)

Space = O(k) where k = paths ending with suffix

-------------------------
Problem 3: Huffman Coding
-------------------------

Huffman encoding is done in following steps:

1. First a tree is generated by creating nodes representing character and its frequency of occurrence. Nodes are
kept in a list. Frequencies are put into a min heap, and two are popped out at a time to generate
a parent node until the whole queue is used.

2. The generated tree is traversed in DFS manner and all left nodes of parent are assigned 0 weight and all
right nodes of parent are assigned 1 weight at each level.

3. The binary values assigned to nodes are used to create a encoding map of characters.

4. Characters in the data are replaced with their binary values

Complexity:


Time:
each character in data is visited to find out frequency = O(n)
min heap push and pop =  O(klog k) where k = unique characters
assign values to nodes = O(k)
encoding each character = O(n)

In worst case huffman encoding = O(nlog n)
on average = O(klog k) where k = unique character count

huffman decoding = O(n)

Space:
Frequency map = O(k) where k no. of unique characters
Nodes map = O(k)
min Queue = O(k)
wighted nodes are saved in list = O(k) where k is no. of nodes

in worst case, space complexity = O(n)

---------------------------
Problem 4: Active Directory
---------------------------

Two strategies are used to speed up user group membership look up:

1. A group's users are kept in a set rather than in a list to make lookup time constant
2. A persistent caching can be used to store list of a user's groups. This cache can be built
when doing lookups:

for example in following hierarchy:

Parent
  |
Child
  |
sub-child

if a user is found in sub-child, all of the parents will be added to user member groups, if not every group will
be added to user not-member list. So on next lookup, membership will be determined even at the top level parent group
by consulting the cache.

The downside of this solution is cache invalidation will become an issue, groups cache of a user can be invalidated
when a user's membership is changed.

Complexity:

Time:
lookup in users set is constant = O(1)
visiting each sub group is = O(n)

overall the time complexity is proportional to total number of sub-groups to search = O(n)

Space:
For caching a user's groups, dict is used.

so space complexity = O(k)  where k= no. of user groups

---------------------
Problem 5: Blockchain
---------------------
Blockchain is represented using a linked list here. Adding a new block calculates
the hash using block's data and hash of previous block.

Complexity:

Time:
Adding blocks to blockchain is constant time operation = O(1)

Space = 0(n)

---------------------------------
Problem 6: Union and Intersection
---------------------------------
We're visiting nodes of linked lists and creating sets of their values, then doing
union and intersection operations on those sets.


For performing either union or intersection, both linked lists have to be traversed:

list traversal => O(len(L1)+len(L2))
union => O(len(L1)+len(L2))
intersection => O(min(len(L1), len(L2))
creating output => O(len(k))  where k = len of union set

time complexity is of the linear order of input = O(n)

space complexity is also linear = O(n)
